## Project #3: Implementing synchronization primitives

### *** Due on 11:59:59pm, June 12 (Friday)***

### Goal
Implement the spinlock and blocking mutex that we learned in the class, and build a multithread-safe ring buffer using your lock primitives.

### Problem Specification
- The template code is so-called lock tester. It will test your lock implementation and ring buffer implementation, which are the goal of this project. It provides extensive options to test the implemntation in a various way. Try to run with `-h` option.

- Running with `-l` will test the correctness of your spinlock implementation. Use `-m` option to test your blocking mutex implementation.
  ```
	$ ./lock -l
	$ ./lock -m
	```

- The correctness testing will take a while, but is supposed to be finished within a minute. Taking longer than this time bound implies two possibilities;
  - Your implementation performs too badly. You need to improve your implementation to pass the test.
  - Blocked indefinitely. Your implementation has some race conditions, making deadlocks and/or starvation. This should be fixed for sure.

- The tester may generate an assertion failure. This also implies your implementation fails to provide the expected properties of the lock primitive.

- You need to implement the spinlock and blocking mutex. The tester will call `init_*`, `acquire_*`, and `release_*` as they are needed, so complete those function. You can insert anything into `struct spinlock` and `struct mutex` as you need.

- Use `compare_and_swap` in `atomic.h` to implement the spinlock.

- To implement the blocking mutex, you should design a mechanism that puts a calling thread into sleep and wakes up waiting threads. Read the comments in the `pa3.c` file carefully for your implementation. Also, you may change `struct thread` for implementing the blocking mutex.
- When multiple threads try to acquire the blocking mutex that is already taken by some other thread, then their mutex acquisition should be handled in FCFS order.
- You may [eat your own dog food](https://en.wikipedia.org/wiki/Eating_your_own_dog_food); may use your spinlock implementation to synchronize waiting threads in the mutex.

- When you run the program with `-r` option, it will test your ring buffer implementation. Basically, the tester simulates n-producer 1-consumer situation, which is discussed in the class. The producers (i.e. generators) generates numbers and enqueue into the ring buffer by calling `enqueue_into_ringbuffer()`. The consumer (i.e., counter) gets numbers from the ring buffer by calling `dequeue_from_ringbuffer()`, and counts the numbers. Your implementation passes the test if and only if the numbers generated by the generators match to the numbers counted by the counter. Mismatching the numbers implies a fault in your implementation.

- In implementing the ring buffer, you can modify `struct ringbuffer` as you need, but you should use `slots` and `nr_slots` **AS IS**, and uses `slots` to buffer values. Modification of this part will revoke your points for the ring buffer implementation.
- You can use any lock primitives that you implemented. Either/both spinlock and/or blocking mutex will be OK as long as your ring buffer runs properly.

- You may get bonus points by completing the following challenges.
  - Implement a **blocking counting** semaphore, and realize the mutex with a binary semaphore configuration.
  - Realize the ring buffer as described on page 8 of 16. Synchronizatoin (3).


### Restriction and tips
- Following cases can be happened if your implementation has a race condition. This means your implementation is **WRONG**, thereby should be fixed to get the points. Thus, questions regarding these situation will not get help from the instructor.
  - Testing fails *SOMETIMES*
  - Testing works *SOMETIMES*
  - Some features are working but some features are not
  - Testing works on your computer but not on the server
  - Testing works on the server but not on your computer
  - Testing works on a set of options but not on a different set of options.

- Due to this uncertainty, confirm that your implementation successfully runs on the server *three times in a row*. You may get reduced points when your submission fails during the grading but there is no three consecutive successes in your submission history. To get guaranteed, submit your final code three times.

- While doing the debugging, you may set `nr_testers` in `tester.c` to 1 to identify the flows of the framework. The grading will be done with 4, though.

- Do not use any `pthread_mutex_*` nor `sem_*` unless listed below
  - `pthread_self`
  - `pthread_kill`
  - `pthread_sigmask`
  - `pthread_sigqueue`

- Install `glibc-doc` package if your system fails to find man pages for `pthread_*` 


### Submission / Grading

- Use [PAsubmit](https://sslab.ajou.ac.kr/pasubmit) for submission
  - 450 points + (100 + 10) bonus points

- Code: pa3.c (400 pts + 100 bonus pts in total)
	- Spinlock: 50 pts
	- Blocking mutex: 250 pts
	- Ring buffer: 100 pts
	- 100 bonus points.
	  - 70 bouns points if you implement a **blocking counting** semaphore, and use it to implement the mutex.
	  - 30 bouns points if you implement the ring buffer using your semaphore.

- Document: One PDF document (50 pts). It should include followings;
  - How the spinlock is implemented.
  - How the blocking mutex is implemented. Specify the thread blocking and waking up mechanisms.
	- Describe your semaphore implementation to get considered for the bonus points.
  - Lessons learned (if you have any)
  - No more than three pages; otherwise you will get 0 pts for the report

- Git repository URL at git.ajou.ac.kr (10 bonus pts)
	- Register http URL and with a deploy token and password.
	- Start the repository by cloning this repository.
	- Make sure the token is valid through June 17 (due + 4 slip days + 1 day)

- *WILL NOT ANSWER THE QUESTIONS ABOUT THOSE ALREADY SPECIFIED ON THE HANDOUT.*
- *QUESTIONS OVER EMAIL WILL BE IGNORED UNLESS IT CONCERNS YOUR PRIVACY.*
